#!/bin/zsh

# zsh autoload function: `sync-cursor`
# Synchronize VS Code and Cursor extensions against list files.
# - Auto-detect push/pull direction by comparing mtimes (installed vs list)
# - Uses zsh builtins where possible for portability and performance

  emulate -L zsh
  setopt pipefail

  # ---------- helpers ----------

  _sync_ext_info() { print -r -- "$@" }

  _sync_ext_cmd_path() {
    local cmd=$1
    command -v -- $cmd 2>/dev/null || true
  }

  _sync_ext_dir_for() {
    local editor=$1
    case $editor in
      code)   print -r -- "$HOME/.vscode/extensions" ;;
      cursor) print -r -- "$HOME/.cursor/extensions" ;;
      *)      return 1 ;;
    esac
  }

  _sync_ext_latest_mtime() {
    local path=$1
    local -A S
    local latest=0
    if [[ -e $path ]]; then
      zmodload -F zsh/stat b:zstat 2>/dev/null || true
      if zstat -H S -- "$path" 2>/dev/null; then
        latest=${S[mtime]%.*}
      fi
      local d m
      for d in $path/*(/N); do
        if zstat -H S -- "$d" 2>/dev/null; then
          m=${S[mtime]%.*}
          (( m > latest )) && latest=$m
        fi
      done
    fi
    print -r -- $latest
  }

  _sync_ext_file_mtime() {
    local f=$1
    local -A S
    local m=0
    if [[ -e $f ]]; then
      zmodload -F zsh/stat b:zstat 2>/dev/null || true
      if zstat -H S -- "$f" 2>/dev/null; then
        m=${S[mtime]%.*}
      fi
    fi
    print -r -- $m
  }

  _sync_ext_human_time() {
    local epoch=$1
    if (( epoch == 0 )); then
      print -r -- "N/A"
      return
    fi
    if date -r $epoch "+%Y-%m-%d %H:%M:%S" >/dev/null 2>&1; then
      date -r $epoch "+%Y-%m-%d %H:%M:%S"
    else
      date -d @$epoch "+%Y-%m-%d %H:%M:%S" 2>/dev/null || print -r -- $epoch
    fi
  }

  _sync_ext_read_list() {
    local file=$1
    local -a lines out
    if [[ -r $file ]]; then
      IFS=$'\n' lines=(${(f)$(<"$file")})
      local l
      for l in $lines; do
        l=${l%$'\r'}
        l=${l##[[:space:]]#}
        l=${l%%[[:space:]]#}
        [[ -z ${l//[[:space:]]/} || $l == \#* ]] && continue
        [[ $l == *.* && $l != *[[:space:]]* ]] || continue
        out+="$l"
      done
    fi
    print -r -l -- $out
  }

  _sync_ext_write_list() {
    local file=$1; shift
    mkdir -p -- ${file:h}
    printf '%s\n' "$@" >| "$file"
  }

  _sync_ext_installed() {
    local cmd=$1
    local -a out
    out=(${(f)$("$cmd" --list-extensions 2>/dev/null)})
    print -r -l -- ${(ou)out}
  }

  _sync_ext_apply_changes() {
    local cmd=$1
    shift
    local action=$1
    shift
    local -a items=($@)
    local flag
    case $action in
      install)   flag="--install-extension" ;;
      uninstall) flag="--uninstall-extension" ;;
      *) return 1 ;;
    esac
    local x
    for x in $items; do
      "$cmd" $flag "$x" || return $?
    done
  }

  _sync_ext_sync_editor() {
    local editor=$1
    local list_file=$2
    _sync_ext_info "üìã ${editor:u}:"
    local cmd=$(_sync_ext_cmd_path $editor)
    if [[ -z $cmd ]]; then
      _sync_ext_info "   ‚ö†Ô∏è  Missing $editor CLI. Skipping extension sync."
      return 0
    fi
    if [[ ! -e $list_file ]]; then
      _sync_ext_info "   ‚ö†Ô∏è  Extensions list not found. Skipping extensions sync."
      return 0
    fi
    local ext_dir=$(_sync_ext_dir_for $editor)
    local ext_ts=$(_sync_ext_latest_mtime "$ext_dir")
    local list_ts=$(_sync_ext_file_mtime "$list_file")
    _sync_ext_info "   Extension timestamp: $(_sync_ext_human_time $ext_ts)"
    _sync_ext_info "   List file timestamp: $(_sync_ext_human_time $list_ts)"
    if (( ext_ts > list_ts )); then
      _sync_ext_info "   ‚Üí Extensions are newer, pushing to list file..."
      local -a installed
      installed=($(_sync_ext_installed "$cmd"))
      _sync_ext_write_list "$list_file" $installed
      _sync_ext_info "   ‚úÖ List updated: ${#installed} extensions written to ${list_file}"
    else
      _sync_ext_info "   ‚Üí List file is newer, pulling from list..."
      local -a desired installed to_install to_uninstall
      desired=($(_sync_ext_read_list "$list_file"))
      installed=($(_sync_ext_installed "$cmd"))
      typeset -A desired_set installed_set
      local x
      for x in $desired; do desired_set[$x]=1; done
      for x in $installed; do installed_set[$x]=1; done
      # Safety: if list is empty but there are installed extensions, skip uninstalling everything
      if (( ${#desired} == 0 && ${#installed} > 0 )); then
        _sync_ext_info "   ‚ö†Ô∏è  List has 0 entries; skipping uninstall to avoid wiping all extensions."
        return 0
      fi
      for x in $desired; do [[ -z ${installed_set[$x]-} ]] && to_install+="$x"; done
      for x in $installed; do [[ -z ${desired_set[$x]-}   ]] && to_uninstall+="$x"; done
      if (( ${#to_install} )); then
        _sync_ext_apply_changes "$cmd" install $to_install || return $?
      fi
      if (( ${#to_uninstall} )); then
        _sync_ext_apply_changes "$cmd" uninstall $to_uninstall || return $?
      fi
      if (( ${#to_install} || ${#to_uninstall} )); then
        _sync_ext_info "   ‚úÖ Sync complete: ${#to_install} installed, ${#to_uninstall} uninstalled"
      else
        _sync_ext_info "   ‚úÖ Already in sync: ${#installed} extensions"
      fi
    fi
  }

  # ---------- main ----------

  _sync_ext_info "üîÑ VSCode/Cursor Extension Sync - Auto-detecting sync direction..."
  local cfg_dir=${ZDOTDIR:-$HOME/.config/dotfiles/zsh}
  local vscode_list="$cfg_dir/../vscode/extensions.txt"
  local cursor_list="$cfg_dir/../cursor/extensions.txt"
  _sync_ext_sync_editor code   "$vscode_list"
  _sync_ext_sync_editor cursor "$cursor_list"
  _sync_ext_info "‚úÖ Extension sync complete!"


